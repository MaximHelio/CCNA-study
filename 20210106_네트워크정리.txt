Network(3계층, 네트워크(인터넷)계층) (매우 중요)
-개요
	-> 상위 레벨 데이터 패킷(Packet, 전송되는 데이터)_모뎀_안으로 캡슐화(들어오는 신호를 모두 묶어서)
	-> 해서 데이터 종류에 상관없이 한 호스트(PC)에서 다른 호스트로 그 패킷들을 
	-> 라우팅(Routing, 전송)하는 것을 말한다.
	
		인터넷 망
	
	Transport  계층모뎀
	네트워크	  라우터
		  스위치
	  	  pc

	-> 라우터는 각 호스트에 부여할 IP 주소를 구성(IP table)해서 배포한다.
	
- 기본 장비 및 기타
	-> Router(라우터, 3계층의 대표적인 장비, IP주소를 설정하는 장비)
	-> 거기에 사용되는 프로토콜:
	-> IP Address, ICMP, IGMP, ARP, RARP

- Class별 분석

	class A
						     (옥텟,octet)
	128	    64    32     16    8     4     2        1. 8bit . 8bit . 8bit
	 0(불변) ||	     Network ID	                         || Host ID(가변)
	=> 불변이라는 말은 신호가 들어오든 말든 0으로 받겠단 소리

	모든 bit에 '0'이라는 신호가 들어가면, 해당 bit의 값들을 사용하지 않고(시작 주소)
	모든 bit에 '1'이라는 신호가 들어가면, 해당 bit의 값들을 모두 더한다.(끝 주소)
	주소라는 건 하나만 얘기하는 게 아니라 어디서부터 어디라는 것을 의미    
	따라서 다음과 같은 주소 범위를 구할 수 있다.

	 	0.0.0.0 ~ 127.(0~255).(0~255).(0~255)
	
	class B							    

	128	    64    		32     16    8     4     2        1. 8bit . 8bit . 8bit
	 1	0(불변) ||	     Network ID	                       		|| Host ID(가변)
	=> 불변이라는 말은 신호가 들어오든 말든 0으로 받겠단 소리

	모든 bit에 '0'이라는 신호가 들어가면, 해당 bit의 값들을 사용하지 않고(시작 주소)
	모든 bit에 '1'이라는 신호가 들어가면, 해당 bit의 값들을 모두 더한다.(끝 주소)
	주소라는 건 하나만 얘기하는 게 아니라 어디서부터 어디라는 것을 의미    
	따라서 다음과 같은 주소 범위를 구할 수 있다.
	 	128.0.0.0 ~ 191.255.(0~255).(0~255)

	class C

	128	    64    	32     	16    8     4     2        1. 8bit . 8bit . 8bit
	 1	     1     0(불변) ||	     Network ID	                      || Host ID(가변)
	=> 불변이라는 말은 신호가 들어오든 말든 0으로 받겠단 소리

	모든 bit에 '0'이라는 신호가 들어가면, 해당 bit의 값들을 사용하지 않고(시작 주소)
	모든 bit에 '1'이라는 신호가 들어가면, 해당 bit의 값들을 모두 더한다.(끝 주소)
	주소라는 건 하나만 얘기하는 게 아니라 어디서부터 어디라는 것을 의미    
	따라서 다음과 같은 주소 범위를 구할 수 있다.
	 	192.0.0.0 ~ 223.255.255.(0~255)


- 서브네팅 시 어떤 대역을 주어지느냐에 따라 중요
	
- 네트워크 id도 가변?

- Class 별 분석?
	->  이미지 참고할 것(Module 00. 36p~37p)

- 구분(서브넷의 역할)
	-> 구분
		: Network ID(대역. Bandwidth)와 Host ID(PC에 부여할 IP주소 개수를 구분)를 구분하는 역할
	
	-> 각 대역 별 서브넷 마스트
		:  Class A 	255(NID).0.0.0(HID)		/8
		:  Class B		255.255(NID).0.0(HID)	/16
		:  Class C		255.255.255(NID).0(HID)	/24
	
- 각 대역별 IP제외 대역(예약이 되어있기 때문에, PC에 실제 부여할 수 없는 IP 주소)
	-> Class A
		: 전체 네트워크 대역에서 50%를 사용
		: 0.0.0.0(전체 네트워크 Address)
		: 10.x.x.x(사설 IP Address)
		: 127.0.0.1(Local Loopback Address)

	-> Class B
		: 전체 네트워크 대역에서 25%를 사용
		:  169.254.x.x (APIPA, 통신이 안될 경우 정상적인 통신이 될 때까지 주소값을 부여잡고 있는 주소)
			-> ipconfig /all에서 ipv4가 위 주소로 되어있음
			-> 정상적인 통신 될 때까지 이 주소값으로 부여잡고 있음
			-> Automatic Private IP Addressing, 자동 개인 IP 주소 할당
			-> class B가 그걸 담당해?
		: 172.16.x.x ~172.31.x.x(사설 IP Address_서브넷팅할 때)	
	
	-> Class C
		: 전체 네트워크에서 12.5% 사용
		: 192.168.0.0 ~ 192.168.255.0 (사설 IP Address)
		 	-> 리눅스에서는 192.168로 시작하는 ip를 모두 부여할 수 있음
			-> virtual network editor samvm/m16_ssmwin11(128gb)
		
		
- 데이터 전송 방식에 따른 분류(Module 00. 39p~41p)
	- Unicast
		• A Host가 B Host에게 Data를 전달하는 가장 일반적인 방법이다.
		• Source Address와 Destination Address를 명시하여 해당하는 장비만이 데이터를 처리하는 방법이다.
		• 동일한 정보를 많은 호스트에 전달 시에는 비 효율적인 방법일수 있다.
		• Host to Host 전달을 기반으로 함으로 다른 Host에 부하는 주지 않는다.
	- Multicast
		• 단일 Host가 예약된 주소(Multicast Address)
		• 목적지 주소를 각 주소에 예약된 Multicast Address를 입력하여 전달한다. 모든 호스트는 이 메시지를 수신한다.
		• 동일한 정보를 한번에 여러 호스트에게 전달하는 장점을 갖는다.
	- Broadcast
		•단일 Host가 Segment에 모든 호스트를 대상으로 Data를 전달 시 사용된다.
		• 목적지 주소를 각 주소에 예약된 Broadcast Address를 입력하여 전달한다. 모든 호스트는 이 메시지를 수신한다.
		• 동일한 정보를 한번에 모든 호스트에게 전달하는 장점을 갖는다.
		• 많은 Broadcast는 호스트의 성능저하를 가져온다.
	
- Subnetting(서브네팅)
	: 개요
		-> 하나의 네트워크 ID를 필요한 크기만큼 나누어 주는 기술을 말한다.
	A회사	1,000,000/월 회선사용료 냄	128개 (ISP로부터 부여받은 공인 IP)	4개(실제 사용중인 IP)	124개(잉여 IP)	59.12.5.xxx
	B회사	100,000/월 회선사용료 냄	48개 (ISP로부터 부여받은 공인 IP)	24개(실제 사용중인 IP)	24개(잉여 IP)	121.160.3.xxx
	C회사	1,000/월 회선사용료 냄	0개 (ISP로부터 부여받은 공인 IP)	0개(실제 사용중인 IP)	0개(잉여 IP)	x

	만약, C회사가 130개의 IP를 필요로 한다면, A회사, B회사처럼 새로운 IP를 부여받아야 한다.
	이렇게 된다면, 각 업체별로 사용 안하는 잉여 IP는 결국 버리게 되는 결과가 발생하고, IP는 전 세계적으로 절대 부족할 수밖에 없음.
	몇 년 전 벌써 IP가 고갈됨 -> IPv6가 개발됨 우린 IPv4를 썼지만 실제적으로는 IPv6를 쓰고 있는 것
	이때 남는 잉여IP를 필요로 하는 업체에게 부여한다면, 부족한 IP 를 최대한 확보할 수 있게 되는데, 이때 필요한 기법이 바로 'subneting'이 된다.

	이렇게 서브네팅을 한 후, C회사는 A회사와 B회사에서 사용중인 2개의 IP대역(59, 121~)을 사용하게 된다. 
	이때, 2개의 라우터가 필요하게 되는데 라우터는 한 개의 대역 당 반드시 한 개만 존재하기 때문이다. 


- 실습(module00. 42p, 43p)
	-> 주어진 대역(218.128.32.0/24)
	-> 초기 확인 작업
		: 1. 주어진 대역이 속한 Class? C (218이 속한 클래스는 C)
		: 2. 확인된 Class의 기본 Subnet Mask? C클래스의 255.255.255.0
		: 3. 각 대역 당 호스트 개수는? 한 대역 당 25개의 Host를 주고싶습니다 ( PC가 25대인 것 )
	-> 분석
	
	C클라스라서	<서브넷 개수> <호스트 개수>		<서브네팅 후 각 대역별 범위>		<각 대역별 Subnet Mask> 		<CIDR 표기>
	8 + 8 + 8 + 	128  64  32   || 16  8  4  2  1
	
			000	00000(시작주소) ~ 11111(끝주소) 	218.128.32.0 ~ 218.128.32.31		     255.255.255.224		218.128.32.0/27
			001					218.128.32.32 ~ 218.128.32.63						218.128.32.32/27
			010					218.128.32.64 ~ 218.128.32.95						218.128.32.64/27
			011					218.128.32.96 ~ 218.128.32.127						218.128.32.96/27
			100					218.128.32.128 ~ 218.128.32.159						218.128.32.128/27
			101					218.128.32.160 ~ 218.128.32.191						218.128.32.160/27
			110					218.128.32.192 ~ 218.128.32.223						218.128.32.192/27
			111 					218.128.32.224 ~ 218.128.32.255						218.128.32.224/27

	-> 서브넷의 개수는 8개가 되고, 각 대역당 32개씩 잡아줄 수 있음
	-> 각 대역별  Subnet Mask와 CIDR 표기
		: 각 대역별 Subnet Mask (서브넷 개수의 각 bit에 할당된 값을 모두 더한다.)
		: CIDR 표기 (앞의 3개 옥텟의 bit수와 서브넷 개수의 각 bit의 개수를 더한다.)
	
	
	



















